---
title: "langevitour examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{langevitour examples}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<style>
h2,h3,h4 { margin-top: 200px; }
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r install, eval=FALSE}
remotes::install_github("pfh/langevitour")
```

```{r setup}
library(langevitour)
```

Things to try:

* Drag labels onto the plot.
* Set point repulsion to "local".
* Experiment with "damping" and "heat".

## Palmer Station Penguins

Measurements of penguins. Since the measurements are in different units, we supply an appropriate scaling.

```{r}
library(palmerpenguins)

completePenguins <- na.omit(penguins[,c(1,3,4,5,6)])
scale <- apply(completePenguins[,-1], 2, sd)*4

langevitour(completePenguins[,-1], completePenguins$species, scale=scale, pointSize=2)
```


## Mouse brain cells

Single-cell RNA-Seq gene expression of 2,816 mouse brain cells ([Zeisel, 2015](https://pubmed.ncbi.nlm.nih.gov/25700174/)). The top 10 principal components were produced using the steps in the [Bioconductor OSCA workflow](http://bioconductor.org/books/3.13/OSCA.workflows/zeisel-mouse-brain-strt-seq.html). This is unscaled PCA of log$_2$(normalized_count+1) expression levels, mean UMI count 15,550 per cell. So $x$ units of distance can be explained for example by $n$ genes with $x/\sqrt{n}$ log$_2$ fold change each.

* Try setting point repulsion to "local".
* Examine particular cell types in detail by turning off the other cell types.

```{r}
data(zeiselPC)

langevitour(zeiselPC[,-1], zeiselPC$type)
```


## Mouse brain cells with k-NN averaging

We can reduce the noise in this data by averaging each cell with its 30 nearest neighbors.

* Try to separate microglia, astrocytes_ependymal and endothelial-mural cells by dragging their labels onto the plot.
* Find principal components components that distinguish these cells and try dragging them onto the plot instead.

```{r}
X <- as.matrix(zeiselPC[,-1])
neighbors <- RANN::nn2(X, k=30)$nn.idx
XSmooth <- lapply(seq_len(nrow(X)), \(i) colMeans(X[neighbors[i,],]))
XSmooth <- do.call(rbind, XSmooth)

langevitour(XSmooth, zeiselPC$type)
```



## Olive oils

A dataset from the [tourr](http://ggobi.github.io/tourr/) package.

By default, langevitour does not scale variables individually. This dataset rather requires scaling, so we supply our desired scaling.

I also demonstrate adding extra axes representing principal components and rotated principal components. The package GPArotation provides many rotation methods. Using the Bentler method to produce sparse scores seems to highlight interesting structure.

```{r}
olives <- tourr::olive[,3:10]
olivesScale <- apply(olives, 2, sd)
olivesGroup <- paste(tourr::olive$region, tourr::olive$area)

# Find principal components
pca <- prcomp(sweep(olives, 2, olivesScale, "/"), rank=4)
olivesPC <- sweep(pca$rotation, 1, olivesScale, "/")

# Find a good rotation of the loadings from PCA
rotation <- GPArotation::bentlerT(pca$x)$Th
olivesR <- olivesPC %*% rotation
colnames(olivesR) <- paste0("R",seq_len(ncol(olivesR)))


langevitour(
    olives, 
    group=olivesGroup, 
    scale=olivesScale*6, 
    extraAxes=cbind(olivesPC, olivesR),
    pointSize=1.5)
```


## Hyper-cube

Some geometry from the [Geo Zoo](https://github.com/schloerke/geozoo).

```{r}
langevitour(geozoo::cube.dotline(5)$points)
```

## Torus

```{r}
langevitour(geozoo::torus.flat(p=4)$points)
```

## pdfsense

A dataset in the [liminal](https://sa-lee.github.io/liminal/) package. Each row has been scaled to a unit vector.

```{r}
X <- as.matrix(liminal::pdfsense[,-(1:6)])
X <- X / sqrt(rowSums(X*X))
langevitour(X, liminal::pdfsense$Type)
```

## Stiefel manifold $V_a(\mathbb{R}^b)$

The orthonormal projections of b dimensions onto a.

Stiefel manifolds are what langevitour tours!

```{r}
stiefel <- function(a,b) {
    k <- 5000
    
    X <- matrix(nrow=k, ncol=a*b)
    colnames(X) <- paste0("X[",rep(seq_len(a),b),",",rep(seq_len(b), each=a),"]")
    for(i in seq_len(k)) {
        mat <- matrix(rnorm(a*b), nrow=a)
        decomp <- svd(mat)
        mat <- decomp$u %*% t(decomp$v)
        X[i,] <- as.vector(mat)
    }
    
    langevitour(X)
}

stiefel(2,3)
```

```{r}
stiefel(2,2)
```